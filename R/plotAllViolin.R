#'Generates violin plots for all possible combinations of continuous and discrete variables
#'within a collection set
#'
#'@param outputFolder: location to folder generated by parseCollection()
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
#' @param palette: a character specifying a RColorbrewer palette to apply to generated visualizations
#' @param writePlots: logical, if true, plots will be written saved as .PNGs in addition
#' to being returned as ggplot objects
#' @param marblesAsDiscrete: logical, dictating if the selection of a marble should
#' used as a discrete variable within the generated plots
#' @param setOutputLocation: logical, if true users will be prompted via GUI to set a location to
#' write out generated plots
#' @param subsetIDs: A vector of question IDs in character format.  Question IDs can be
#' found in the ID column of the outline file.  Use this argument to generate violin plots for
#' a subset of the signifiers instead of the entire set.
#' @param sliderAxis: a vector of length 1-2, containg character(s) 'X', 'Y', or both.
#' These characters indicate which axes within sliders to use, X, it's inverse, or both.
#'
plotAllViolin <- function(outputFolder, showMean = TRUE, palette = NULL,
                          writePlots = FALSE, marblesAsDiscrete = FALSE,
                          setOutputLocation = FALSE, subsetIDs = NULL,
                          sliderAxes = c("X")){

  sliderAxes <- toupper(sliderAxes)

  discreteClasses <- c("discrete")

  if(marblesAsDiscrete){
    discreteClasses <- c("discrete", "marble")
  }

  #Save paths to data folders
  discretePath <- paste0(outputFolder, "/Data/discreteData.xlsx")
  continuousPath <- paste0(outputFolder, "/Data/continuousData.xlsx")

  #Read in outline file
  outline <- read.xlsx(paste0(outputFolder, "/Data/outline.xlsx"), sheetIndex = 1)

  #Convert comma separated values to lists of vectors
  outline$CONTINUOUS_LABELS <- toList(outline$CONTINUOUS_LABELS)
  outline$DISCRETE_LABELS <- toList(outline$DISCRETE_LABELS)
  outline$LEVELS <- toList(outline$LEVELS)


  #------------------------------

  if(is.null(subsetIDs)) {
    subsetIDs = outline$ID
  }

  #Ensure signifier IDs are being treated as chars
  subsetIDs = as.character(subsetIDs)

  #Get the sheet indices for selected continuous signifiers within the continuous data file
  continuousOutline <- filter(outline, CLASS != "discrete")
  continuousOutline$sheetInd <- c(1:NROW(continuousOutline))


  #Get the sheet indices for selected discrete signifiers within the discrete data file
  discreteOutline <- filter(outline, CLASS %in% discreteClasses)
  discreteOutline$sheetInd <- c(1:NROW(discreteOutline))


  #separate outline entries for discrete and continuous data
  discreteOutline <- filter(discreteOutline, ID %in% subsetIDs)
  continuousOutline <- filter(continuousOutline, ID %in% subsetIDs)

  #Store data sheet indices for continuous and discrete data
  discSheetInds <- discreteOutline$sheetInd
  contSheetInds <- continuousOutline$sheetInd


  #Read in subset of continuous data
  continuousData <- lapply(contSheetInds, function(x){
    data = read.xlsx(continuousPath, sheetIndex = x, check.names = FALSE) %>%
      select(-c(IS_NA))

    if(continuousOutline[continuousOutline$sheet == x,]$CLASS == "slider"){
      data = as.data.frame(data[,sliderAxes])
      names(data) = sliderAxes
    }
    return(data)
  })

  #read in subset of discrete data
  discreteData <- lapply(discSheetInds, function(x){
    return(read.xlsx(discretePath, sheetIndex = x, check.names = FALSE))
  })

    #if user didn't provide a subset of signifiers to use, read in all collection data
    #from continuous and discrete data files

  #initialize fill container
  discreteFills <- list()
  #initialize label pair container
  discreteLabPairs <- list()


  #Iterate over discrete data, format data for each signifier, generate fills for
  #each level
  for(i in 1:length(discreteData)){
    #Format discrete data
    discreteData[[i]] <- formatDiscrete(discreteData[[i]]$SET, discreteOutline[i,])
    #Generate a set of fills for each discrete question

    nLevels <- length(levels(discreteData[[i]]$SET))

    discreteFills[[i]] <- colorRampPalette(brewer.pal(8, palette))(nLevels)


    #Get list of labels to use for each discrete level within plots
    discreteLabPairs[[i]] <- generateDiscreteLabels(discreteOutline[i,])
  }

  #return(discreteData)

  #Initialize result container and plot indexing variable
  plots <- list()
  plotInd = 1

  #for each continuous signifier
  for(i in 1:length(continuousData)){

    #Get the associated continuous observation for this signifier from the outline
    thisOutline <- continuousOutline[i,]
    #Get the title for the continuous signifier
    title <- continuousOutline[i,]$QUESTION

    #Get data for this continuous signifier
    thisContinuous <- continuousData[[i]]


    #for reach discrete data question
    for(j in 1:length(discreteData)){
      #get question title for discrete data
      ylab <- discreteOutline[j,]$QUESTION
      #get all selected factors for this
      thisDiscrete <- discreteData[[j]]

      print(thisDiscrete)
      #for each column in continuous data question
      for(k in 1:NCOL(thisContinuous)){
        #get x axis label
        xlab <- generateXLabel(thisOutline, k)
        #generate plot
        p <- violinPlot(continuous = thisContinuous[thisDiscrete$ROW_ID, k],
                        discrete = thisDiscrete$SET, fill = discreteFills[[j]],
                        title = title, xlab = xlab, ylab = ylab,
                        showMean = showMean, labelPairs = discreteLabPairs[[j]])

        plots[[plotInd]] <- p

        plotInd <- plotInd + 1



      }

    }
  }

  #save plots as .png
  if(writePlots){
    if(setOutputLocation){
      writePlots(plots)
    } else {
      writePlots(plots, path = paste0(outputFolder, "/Visualizations"))
    }

    return(plots)
  } else{
    return(plots)
  }

}

#' Generates a violin plot
#' @param continuous: a set of vector of continuous data
#' @param discrete: a set of discrete data of equal length to continuous
#' @param title: char, plot title
#' @param xlab: char, x axis label
#' @param ylab: char, y axis lable
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
#' @param labelPairs: List with key-value structure.  Each key holds a level of
#' the plots discrete factor, each value holds the corresponding label which should
#' be used for the respective level within the plot
violinPlot <- function(continuous, discrete = NULL, fill = NULL, title = "Title",
                       xlab = "-xlab <---> +xlab", ylab = "ylab",
                       showMean = TRUE, labelPairs = NULL){

  print("from violinplot()")
  print(discrete)

 # print(fill)

  #if no discrete variable is provided, put all into a single level called
  # 'responses'
  if(is.null(discrete)){
    discrete <- rep("respones", NROW(continuous))
  }

  #consolidate plot data into single df, and drop observations with NAs
  plotData <- data.frame(continuous, discrete)
  plotData <- na.omit(plotData)


  #find levels which are present within the data (i.e. not dropped due to NA)
  presentLevels <- factor(plotData$discrete) %>%
    levels()
  #assign y axis tick marks
  yAxisTicks <- unlist(labelPairs[presentLevels])


  p <- ggplot(data = plotData, mapping = aes(x = continuous, y = discrete, fill = discrete)) +
    geom_violin() +
    labs(title = title) +
    xlab(xlab) +
    ylab(ylab) +
    scale_fill_manual(values = fill, breaks = levels(plotData$discrete)) +
    scale_y_discrete(labels = yAxisTicks)

  if(showMean){
    p <- p + stat_summary(data = plotData, mapping = aes(x = continuous, y = discrete),
                          fun = "mean", geom = "point", shape = 8, size = 4,
                          color = "black")
  }

  return(p)

}
