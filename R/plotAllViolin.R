#'Generates violin plots for all possible combinations of continuous and discrete variables
#'within a collection set
#'
#'@param outputFolder: location to folder generated by parseCollection()
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
#' @param palette: a character specifying a RColorbrewer palette to apply to generated visualizations
#' @param writePlots: logical, if true, plots will be written saved as .PNGs in addition
#' to being returned as ggplot objects
#' @param marblesAsDiscrete: logical, dictating if the selection of a marble should
#' used as a discrete variable within the generated plots
#' @param setOutputLocation: logical, if true users will be prompted via GUI to set a location to
#' write out generated plots
#' @param subsetIDs: A vector of question IDs in character format.  Question IDs can be
#' found in the ID column of the outline file.  Use this argument to generate violin plots for
#' a subset of the signifiers instead of the entire set.
#' @param sliderAxis: a vector of length 1-2, containg character(s) 'X', 'Y', or both.
#' These characters indicate which axes within sliders to use, X, it's inverse, or both.
#'
plotAllViolin <- function(outputFolder, showMean = TRUE, palette = NULL,
                          writePlots = FALSE, marblesAsDiscrete = FALSE,
                          setOutputLocation = FALSE, subsetIDs = NULL,
                          sliderAxes = c("X")){

  sliderAxes <- toupper(sliderAxes)

  discreteClasses <- c("discrete")

  if(marblesAsDiscrete){
    discreteClasses <- c("discrete", "marble")
  }

  #Save paths to data folders
  discretePath <- paste0(outputFolder, "/Data/discreteData.xlsx")
  continuousPath <- paste0(outputFolder, "/Data/continuousData.xlsx")

  #Read in outline file
  outline <- read.xlsx(paste0(outputFolder, "/Data/outline.xlsx"), sheetIndex = 1)

  #Convert comma separated values to lists of vectors
  outline$CONTINUOUS_LABELS <- toList(outline$CONTINUOUS_LABELS)
  outline$DISCRETE_LABELS <- toList(outline$DISCRETE_LABELS)
  outline$LEVELS <- toList(outline$LEVELS)


  #------------------------------

  if(is.null(subsetIDs)) {
    subsetIDs = outline$ID
  }

  #Ensure signifier IDs are being treated as chars
  subsetIDs = as.character(subsetIDs)

  #Get the sheet indices for selected continuous signifiers within the continuous data file
  continuousOutline <- filter(outline, CLASS != "discrete")
  continuousOutline$sheetInd <- c(1:NROW(continuousOutline))


  #Get the sheet indices for selected discrete signifiers within the discrete data file
  discreteOutline <- filter(outline, CLASS %in% discreteClasses)
  discreteOutline$sheetInd <- c(1:NROW(discreteOutline))


  #separate outline entries for discrete and continuous data
  discreteOutline <- filter(discreteOutline, ID %in% subsetIDs)
  continuousOutline <- filter(continuousOutline, ID %in% subsetIDs)

  #Store data sheet indices for continuous and discrete data
  discSheetInds <- discreteOutline$sheetInd
  contSheetInds <- continuousOutline$sheetInd


  #Read in subset of continuous data
  continuousData <- lapply(contSheetInds, function(x){
    data = read.xlsx(continuousPath, sheetIndex = x, check.names = FALSE) %>%
      select(-c(IS_NA))
    #print(continuousOutline[x,])
    if(continuousOutline[continuousOutline$sheet == x,]$CLASS == "slider"){
      data = as.data.frame(data[,sliderAxes])
      names(data) = sliderAxes
    }
    return(data)
  })


  # continuousData <- lapply(contSheetInds, function(x){
  #   return(read.xlsx(continuousPath, sheetIndex = x, check.names = FALSE))
  # })

  print(continuousData)

  #read in subset of discrete data
  discreteData <- lapply(discSheetInds, function(x){
    return(read.xlsx(discretePath, sheetIndex = x, check.names = FALSE))
  })

    #if user didn't provide a subset of signifiers to use, read in all collection data
    #from continuous and discrete data files


  #--------------------------------------

  #initialize fill container
  discreteFills <- list()
  #initialize label pair container
  discreteLabPairs <- list()


  #Iterate over discrete data, format data for each signifier, generate fills for
  #each level
  for(i in 1:length(discreteData)){
    #Format discrete data
    discreteData[[i]] <- formatDiscrete(discreteData[[i]]$SET, discreteOutline[i,])
    #Generate a set of fills for each discrete question
    nLevels <- length(levels(discreteData[[i]]$SET))
    discreteFills[[i]] <- colorRampPalette(brewer.pal(8, palette))(nLevels)

    #Get list of labels to use for each discrete level within plots
    discreteLabPairs[[i]] <- generateDiscreteLabels(discreteOutline[i,])
  }

  #return(discreteData)

  #Initialize result container and plot indexing variable
  plots <- list()
  plotInd = 1

  #for each continuous signifier
  for(i in 1:length(continuousData)){

    #Get the associated continuous observation for this signifier from the outline
    thisOutline <- continuousOutline[i,]
    #Get the title for the continuous signifier
    title <- continuousOutline[i,]$QUESTION

    #Get data for this continuous signifier
    thisContinuous <- continuousData[[i]]


    #for reach discrete data question
    for(j in 1:length(discreteData)){
      #get question title for discrete data
      ylab <- discreteOutline[j,]$QUESTION
      #get all selected factors for this
      thisDiscrete <- discreteData[[j]]

      #for each column in continuous data question
      for(k in 1:NCOL(thisContinuous)){
        #get x axis label
        xlab <- generateXLabel(thisOutline, k)
        #generate plot
        p <- violinPlot(continuous = thisContinuous[thisDiscrete$ROW_ID, k],
                        discrete = thisDiscrete$SET, fill = discreteFills[[j]],
                        title = title, xlab = xlab, ylab = ylab,
                        showMean = showMean, labelPairs = discreteLabPairs[[j]])

        plots[[plotInd]] <- p

        # if(plotInd == 19){
        #   print(thisContinuous[thisDiscrete$ROW_ID, k])
        #   print(thisDiscrete$SET)
        #   print(discreteFills[[j]])
        #   #print(p)
        # }

        plotInd <- plotInd + 1



      }

    }
  }

  #save plots as .png
  if(writePlots){
    if(setOutputLocation){
      writePlots(plots)
    } else {
      writePlots(plots, path = paste0(outputFolder, "/Visualizations"))
    }

    return(plots)
  } else{
    return(plots)
  }

}
