#'generates all possible violin plots from collection data output
#'
#'@param outputFolder: location to folder generated by parseCollection()
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
#' @param palette: a character specifying a RColorbrewer palette to apply to generated visualizations
#' @param writePlot: logical, if true, plots will be written saved as .PNGs in addition
#' to being returned as ggplot objects
#' @param setOutputLocation: logical, if true users will be prompted via GUI to set a location to
#' write out generated plots
plotAllViolin <- function(outputFolder, showMean = TRUE,palette = NULL,
                          writePlots = FALSE, setOutputLocation = FALSE,
                          subsetIDs = NULL){

  #save paths to data folders
  discretePath <- paste0(outputFolder, "/Data/discreteData.xlsx")
  continuousPath <- paste0(outputFolder, "/Data/continuousData.xlsx")

  #read in outline file
  outline <- read.xlsx(paste0(outputFolder, "/Data/outline.xlsx"), sheetIndex = 1)

  #convert comma separated values to vectors
  #outline$LABELS <- toList(outline$LABELS)
  outline$CONTINUOUS_LABELS <- toList(outline$CONTINUOUS_LABELS)
  outline$DISCRETE_LABELS <- toList(outline$DISCRETE_LABELS)
  outline$LEVELS <- toList(outline$LEVELS)




  if(!is.null(subsetIDs)){
    #ensure observation IDs are being treated as chars
    subsetIDs = as.character(subsetIDs)

    #Find sheet indices for continuous data
    cOutline <- filter(outline, CLASS != "discrete")
    cSheetInds <- which(cOutline$ID %in% subsetIDs)

    #find sheetIndices for discrete data
    dOutline <- filter(outline, CLASS %in% c("discrete", "marble"))
    dSheetInds <- which(dOutline$ID %in% subsetIDs)


    #subset outline to only include subset
    outline <- outline[outline$ID %in% subsetIDs,]

    #read in continuous data
    continuousData <- lapply(cSheetInds, function(x){
      return(read.xlsx(continuousPath, sheetIndex = x, check.names = FALSE))
    })

    #read in discrete data
    discreteData <- lapply(dSheetInds, function(x){
      return(read.xlsx(discretePath, sheetIndex = x, check.names = FALSE))
    })
    print("HEY 1")

  } else {
    continuousData <- getAllDataSheets(continuousPath)
    discreteData <- getAllDataSheets(discretePath)
    print("HEY")
  }

  print(discreteData)

  continuousOutline <- filter(outline, CLASS != "discrete")


  #read in discrete data and separate discrete outline observations

  discreteOutline <- filter(outline, CLASS %in% c("discrete", "marble"))

  #initialize fill container
  discreteFills <- list()
  discreteLabPairs <- list()




  for(i in 1:length(discreteData)){
    #format discrete data
    discreteData[[i]] <- formatDiscrete(discreteData[[i]]$SET, discreteOutline[i,], palette)
    nLevels <- length(levels(discreteData[[i]]$SET))
    #generate set of fills for each discrete question
    discreteFills[[i]] <- colorRampPalette(brewer.pal(8, palette))(nLevels)
    discreteLabPairs[[i]] <- generateDiscreteLabels(discreteOutline[i,])
  }



  #initialize result container and plot index variable
  plots <- list()
  plotInd = 1

  #for each continuous data question
  for(i in 1:length(continuousData)){

    #get Outline row for this continuous question
    thisOutline <- continuousOutline[i,]

    #get question title for continuous question
    title <- continuousOutline[i,]$QUESTION

    #get continuous data for this question and drop IS_NA col
    thisContinuous <- continuousData[[i]] %>%
      select(-c(IS_NA))

    #for reach discrete data question
    for(j in 1:length(discreteData)){
      #get question title for discrete data
      ylab <- discreteOutline[j,]$QUESTION
      #get all selected factors for this
      thisDiscrete <- discreteData[[j]]

      #for each column in continuous data question
      for(k in 1:NCOL(thisContinuous)){
        #get x axis label
        xlab <- generateXLabel(thisOutline, k)
        #generate plot
        p <- violinPlot(thisContinuous[thisDiscrete$ROW_ID,k], thisDiscrete$SET,
                        fill = discreteFills[[j]], title, xlab, ylab, showMean,
                        labelPairs = discreteLabPairs[[j]])

        plots[[plotInd]] <- p
        plotInd <- plotInd + 1

      }

    }
  }
  #save plots as .png
  if(writePlots){
    if(setOutputLocation){
      writePlots(plots)
    } else {
      writePlots(plots, path = paste0(outputFolder, "/Visualizations"))
    }

    return(plots)
  } else{
    return(plots)
  }

}


#'reads data from each sheet within a .xlsx file
#'
#'@param path: path to a .xslx file
getAllDataSheets <- function(path){
  #organize all discrete data into a list
  wb <- xlsx::loadWorkbook(file = path)
  names <- getSheets(wb) %>%
    names()
  data <- lapply(names, function(x){
    thisDat <- read.xlsx(file = path, sheetName = x, check.names = FALSE)
  })
  return(data)
}

#'generates the labelPairs list, a key-value like structure where the
#'key (name of the element) is the discrete factor level and the value is the
#'label which should appear in generated graphics
#'
#'@param thisOutline: a row from the outline file
generateDiscreteLabels <- function(thisOutline){
  labelPairs <- list()

    for(i in 1:length(thisOutline$LEVELS)){
      thisLevel <- unlist(thisOutline$LEVELS[i])
      labelPairs[thisLevel] <- unlist(thisOutline$DISCRETE_LABELS[i])
    }

  return(labelPairs)
}


#'generates x axis label based on question input and outline file
#'@param thisOutline: row from outline representing current question
#'@param index: index representing current column within question
generateXLabel <- function(thisOutline, index){
  base <- "%s <--------------------------> %s"
  leftLabel <- "-X Label"
  rightLabel <- "+X Label"

  if(thisOutline$CLASS == "marble"){
    if(index%%2 != 0){
      leftLabel <- thisOutline$CONTINUOUS_LABELS[[1]][1]
      rightLabel <- thisOutline$CONTINUOUS_LABELS[[1]][2]
    } else{
      leftLabel <- thisOutline$CONTINUOUS_LABELS[[1]][3]
      rightLabel <- thisOutline$CONTINUOUS_LABELS[[1]][4]
    }
  }else if(thisOutline$CLASS == "slider") {
    leftLabel <- thisOutline$CONTINUOUS_LABELS[[1]][1]
    rightLabel <- thisOutline$CONTINUOUS_LABELS[[1]][2]

  }else if(thisOutline$CLASS == "ternary"){
    leftLabel <- paste0("-",thisOutline$CONTINUOUS_LABELS[[1]][index])
    rightLabel <- paste0("+",thisOutline$CONTINUOUS_LABELS[[1]][index])
  }

  label <- sprintf(base, leftLabel, rightLabel)

  return(label)
}


formatDiscrete <- function(data, thisOutline, palette){

  observations <- c()
  indices <- c()
  #convert comma separated values to vectors
  data <- toList(data)

  #flatten all discrete data, save row indices to keep other obs
  for(i in 1:NROW(data)){
    for(ob in unlist(data[i])){
      observations <- c(observations, ob)
      indices <- c(indices, i)
    }
  }

  #convert to factor, ordered if specified in outline
  if(thisOutline$ORDERED){
    observations <- factor(x = observations, levels = unlist(thisOutline$LEVELS),
                           ordered = TRUE)
  } else{
    observations <- factor(x = observations)
  }



  #generate a fill ID key
  nLevels <- length(levels(observations))
  thisPalette <- colorRampPalette(brewer.pal(8, palette))(nLevels)
  fillKey <- data.frame(fill = thisPalette, level = levels(observations))

  return(data.frame(SET = observations, ROW_ID = indices))

}


#' splits single strings of multiple levels seperated by ', ' into a list of vectors
#' of multiple strings
#' @param data: char vector
toList <- function(data){
  result <- sapply(data, function(x){
    x <- str_split(x, ", ") %>%
      unlist() %>%
      trimws("both")
  }, USE.NAMES = FALSE)

  return(result)
}

#' Generates a violin plot
#' @param continuous: a set of vector of continuous data
#' @param discrete: a set of discrete data of equal length to continuous
#' @param title: char, plot title
#' @param xlab: char, x axis label
#' @param ylab: char, y axis lable
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
violinPlot <- function(continuous, discrete = NULL, fill = NULL, title = "Title",
                       xlab = "-xlab <---> +xlab", ylab = "ylab",
                       showMean = TRUE, labelPairs = NULL){

  #if no discrete variable is provided, put all into a single level called
  # 'responses'
  if(is.null(discrete)){
    discrete <- rep("respones", NROW(continuous))
  }

  #consolidate plot data into single df, and drop observations with NAs
  plotData <- data.frame(continuous, discrete)
  plotData <- na.omit(plotData)


  #find levels which are present within the data (i.e. not dropped due to NA)
  presentLevels <- factor(plotData$discrete) %>%
    levels()
  #assign y axis tick marks
  yAxisTicks <- unlist(labelPairs[presentLevels])


  p <- ggplot(data = plotData, mapping = aes(x = continuous, y = discrete, fill = discrete)) +
    geom_violin() +
    labs(title = title) +
    xlab(xlab) +
    ylab(ylab) +
    scale_fill_manual(values = fill, breaks = levels(plotData$discrete)) +
    #scale_fill_manual(values = fill, breaks = levels(plotData$discrete),
    #                  name = NULL, labels = yAxisTicks) +
    scale_y_discrete(labels = yAxisTicks)

  if(showMean){
    p <- p + stat_summary(data = plotData, mapping = aes(x = continuous, y = discrete),
                          fun = "mean", geom = "point", shape = 8, size = 4,
                          color = "black")
  }

  return(p)

}



#TODO:

plotOneViolin <- function(outputFolder, continuousInd, columnInd,
                          discreteInd = NULL,title = NULL, xlab = NULL,
                          ylab = NULL, showMean = TRUE, palette = NULL){

  outline <- read.xlsx(paste0(outputFolder,"/Data/outline.xlsx"), sheetIndex = 1)

  if(!is.null(discreteInd)){

  }


  cont <- outline[continuousInd,]



  return(outline)

}



