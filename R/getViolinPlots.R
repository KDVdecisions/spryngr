#'generates all possible violin plots from collection data output
#'
#'@param outputFolder: location to folder generated by parseCollection()
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
#' @param palette: a character specifying a RColorbrewer palette to apply to generated visualizations
#' @param writePlot: logical, if true, plots will be written saved as .PNGs in addition
#' to being returned as ggplot objects
#' @param setOutputLocation: logical, if true users will be prompted via GUI to set a location to
#' write out generated plots
plotAllViolin <- function(outputFolder, showMean = TRUE,
                              palette = NULL, writePlots = FALSE,
                          setOutputLocation = FALSE){

  #save paths to data folders
  discretePath <- paste0(outputFolder, "/Data/discreteData.xlsx")
  continuousPath <- paste0(outputFolder, "/Data/continuousData.xlsx")

  #read in outline file
  outline <- read.xlsx(paste0(outputFolder, "/Data/outline.xlsx"), sheetIndex = 1)

  #convert comma separated values to vectors
  outline$LABELS <- toList(outline$LABELS)
  outline$LEVELS <- toList(outline$LEVELS)

  #read in continuous data and separate continuous outline obersvations
  continuousData <- getAllDataSheets(continuousPath)
  cOutline <- filter(outline, CLASS != "discrete")

  #read in discrete data and separate discrete outline observations
  discreteData <- getAllDataSheets(discretePath)
  dOutline <- filter(outline, CLASS %in% c("discrete", "marble"))
  #initialize fill container
  discreteFills <- list()


  for(i in 1:length(discreteData)){
    #format discrete data
    discreteData[[i]] <- formatDiscrete(discreteData[[i]]$SET, dOutline[i,], palette)
    nLevels <- length(levels(discreteData[[i]]$SET))
    #generate set of fills for each discrete question
    discreteFills[[i]] <- colorRampPalette(brewer.pal(8, palette))(nLevels)
  }



  #initialize result container and plot index variable
  plots <- list()
  plotInd = 1

  #for each continuous data question
  for(i in 1:length(continuousData)){

    #get Outline row for this continuous question
    thisOutline <- cOutline[i,]

    #get question title for continuous question
    title <- cOutline[i,]$QUESTION

    #get continuous data for this question and drop IS_NA col
    thisContinuous <- continuousData[[i]] %>%
      select(-c(IS_NA))

    #for reach discrete data question
    for(j in 1:length(discreteData)){
      #get question title for discrete data
      ylab <- dOutline[j,]$QUESTION
      #get all selected factors for this
      thisDiscrete <- discreteData[[j]]

      #for each column in continuous data question
      for(k in 1:NCOL(thisContinuous)){
        #get x axis label
        xlab <- generateXLabel(thisOutline, k)
        #generate plot
        p <- violinPlot(thisContinuous[thisDiscrete$ROW_ID,k], thisDiscrete$SET,
                        fill = discreteFills[[j]], title, xlab, ylab, showMean)

        plots[[plotInd]] <- p
        plotInd <- plotInd + 1

      }

    }
  }
  #save plots as .png
  if(writePlots){
    if(setOutputLocation){
      writePlots(plots)
    } else {
      writePlots(plots, path = paste0(outputFolder, "/Visualizations"))
    }

    return(plots)
  } else{
    return(plots)
  }

}

#TODO:

plotOneViolin <- function(outputFolder, continuousInd, columnInd,
                          discreteInd = NULL,title = NULL, xlab = NULL,
                          ylab = NULL, showMean = TRUE, palette = NULL){

  outline <- read.xlsx(paste0(outputFolder,"/Data/outline.xlsx"), sheetIndex = 1)

  if(!is.null(discreteInd)){

  }


  cont <- outline[continuousInd,]



  return(outline)

}

#'reads data from each sheet within a .xlsx file
getAllDataSheets <- function(path){
  #organize all discrete data into a list
  wb <- xlsx::loadWorkbook(file = path)
  names <- getSheets(wb) %>%
    names()
  data <- lapply(names, function(x){
    thisDat <- read.xlsx(file = path, sheetName = x, check.names = FALSE)
  })
  return(data)
}





#'generates x axis label based on question input and outline file
#'@param thisOutline: row from outline representing current question
#'@param index: index representing current column within question
generateXLabel <- function(thisOutline, index){
  base <- "%s <--------------------------> %s"
  leftLabel <- "-X Label"
  rightLabel <- "+X Label"

  if(thisOutline$CLASS == "marble"){
    if(index%%2 != 0){
      leftLabel <- thisOutline$LABELS[[1]][1]
      rightLabel <- thisOutline$LABELS[[1]][2]
    } else{
      leftLabel <- thisOutline$LABELS[[1]][3]
      rightLabel <- thisOutline$LABELS[[1]][4]
    }
  }else if(thisOutline$CLASS == "slider") {
    leftLabel <- thisOutline$LABELS[[1]][1]
    rightLabel <- thisOutline$LABELS[[1]][2]

  }else if(thisOutline$CLASS == "ternary"){
    leftLabel <- paste0("-",thisOutline$LABELS[[1]][index])
    rightLabel <- paste0("+",thisOutline$LABELS[[1]][index])
  }

  label <- sprintf(base, leftLabel, rightLabel)

  return(label)
}


formatDiscrete <- function(data, thisOutline, palette){

  observations <- c()
  indices <- c()
  #convert comma separated values to vectors
  data <- toList(data)

  #flatten all discrete data, save row indices to keep other obs
  for(i in 1:NROW(data)){
    for(ob in unlist(data[i])){
      observations <- c(observations, ob)
      indices <- c(indices, i)
    }
  }

  #convert to factor, ordered if specified in outline
  observations <- factor(x = observations, levels = unlist(thisOutline$LEVELS),
                         ordered = thisOutline$ORDERED)

  #generate a fill ID key
  nLevels <- length(levels(observations))
  thisPalette <- colorRampPalette(brewer.pal(8, palette))(nLevels)
  fillKey <- data.frame(fill = thisPalette, level = levels(observations))

  return(data.frame(SET = observations, ROW_ID = indices))

}


#' splits single strings of multiple levels seperated by ', ' into a list of vectors
#' of multiple strings
#' @param data: char vector
toList <- function(data){
  result <- sapply(data, function(x){
    x <- str_split(x, ", ") %>%
      unlist() %>%
      trimws("both")
  }, USE.NAMES = FALSE)

  return(result)
}

#' Generates a violin plot
#' @param continuous: a set of vector of continuous data
#' @param discrete: a set of discrete data of equal length to continuous
#' @param title: char, plot title
#' @param xlab: char, x axis label
#' @param ylab: char, y axis lable
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
violinPlot <- function(continuous, discrete = NULL, fill = NULL, title = "Title",
                       xlab = "-xlab <---> +xlab", ylab = "ylab",
                       showMean = TRUE){

  if(is.null(discrete)){
    discrete <- rep("respones", NROW(continuous))
  }

  plotData <- data.frame(continuous, discrete)
  plotData <- na.omit(plotData)


  p <- ggplot(data = plotData, mapping = aes(x = continuous, y = discrete, fill = discrete)) +
    geom_violin() +
    labs(title = title) +
    xlab(xlab) +
    ylab(ylab) +
    scale_fill_manual(values = fill)
    #scale_fill_manual(values = fill, breaks = levels(plotData$discrete)) ???

  if(showMean){
    p <- p + stat_summary(data = plotData, mapping = aes(x = continuous, y = discrete),
                          fun = "mean", geom = "point", shape = 8, size = 4,
                          color = "black")
  }

  return(p)

}






