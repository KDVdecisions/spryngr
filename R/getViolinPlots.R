



# (continuous, discrete = NULL, title = "Title",
#   xlab = "-xlab <---> +xlab", ylab = "ylab",
#   flatten = TRUE,
#   showMean = TRUE,
#   palette = NULL)

#'generates all possible violin plots from collection data output
#'
#'@param outputFolder: location to folder generated by parseCollection()
#'@param flattenlogical, if true all responses within discrete data including
#' multiple selected levels will be treated as their own level,
#' if false responses with multiple selected levels will be split into multiple occurrences
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
#' @param palette: a character specifying a RColorbrewer palette to apply to generated visualizations
#' @param writePlot: logical, if true, plots will be written saved as .PNGs in addition
#' to being returned as ggplot objects
#' @param setOutputLocation: logical, if true users will be prompted via GUI to set a location to
#' write out generated plots
plotAllViolin <- function(outputFolder, flatten = TRUE, showMean = TRUE,
                              palette = NULL, writePlots = FALSE,
                          setOutputLocation = FALSE){


  discretePath <- paste0(outputFolder, "/Data/discreteData.xlsx")
  continuousPath <- paste0(outputFolder, "/Data/continuousData.xlsx")

  outline <- read.xlsx(paste0(outputFolder, "/Data/outline.xlsx"), sheetIndex = 1)

  outline$LABELS <- toList(outline$LABELS)

  continuousData <- getAllDataSheets(continuousPath)
  cOutline <- filter(outline, CLASS != "discrete")

  discreteData <- getAllDataSheets(discretePath)
  dOutline <- filter(outline, CLASS %in% c("discrete", "marble"))


  plots <- list()
  plotInd = 1

  for(i in 1:length(continuousData)){

    #get Outline row for continuous data
    thisOutline <- cOutline[i,]

    #get question title for continuous data
    title <- cOutline[i,]$QUESTION

    #get continuous data for this question and drop IS_NA col
    thisContinuous <- continuousData[[i]] %>%
      select(-c(IS_NA))


    for(j in 1:length(discreteData)){
      #get question title for discrete data
      ylab <- dOutline[j,]$QUESTION
      #get all selected factors for this
      thisDiscrete <- discreteData[[j]]$SET


      for(k in 1:NCOL(thisContinuous)){
        xlab <- generateXLabel(thisOutline, k)
        p <- violinPlot(thisContinuous[,k], thisDiscrete, title, xlab, ylab,
                        flatten, showMean, palette)
        plots[[plotInd]] <- p
        plotInd <- plotInd + 1

      }

    }
  }
  if(writePlots){
    if(setOutputLocation){
      writePlots(plots)
    } else {
      writePlots(plots, path = paste0(outputFolder, "/Visualizations"))
    }

    return(plots)
  } else{
    return(plots)
  }

}


#'reads data from each sheet within a .xlsx file
getAllDataSheets <- function(path){
  #organize all discrete data into a list
  wb <- xlsx::loadWorkbook(file = path)
  names <- getSheets(wb) %>%
    names()
  data <- lapply(names, function(x){
    thisDat <- read.xlsx(file = path, sheetName = x, check.names = FALSE)
  })
  return(data)
}





#'generates x axis label based on question input and outline file
#'@param thisOutline: row from outline representing current question
#'@param index: index representing current column within question
generateXLabel <- function(thisOutline, index){
  base <- "%s <--------------------------> %s"
  leftLabel <- "-X Label"
  rightLabel <- "+X Label"

  if(thisOutline$CLASS == "marble"){
    if(index%%2 != 0){
      leftLabel <- thisOutline$LABELS[[1]][1]
      rightLabel <- thisOutline$LABELS[[1]][2]
    } else{
      leftLabel <- thisOutline$LABELS[[1]][3]
      rightLabel <- thisOutline$LABELS[[1]][4]
    }
  }else if(thisOutline$CLASS == "slider") {
    leftLabel <- thisOutline$LABELS[[1]][1]
    rightLabel <- thisOutline$LABELS[[1]][2]

  }else if(thisOutline$CLASS == "ternary"){
    leftLabel <- paste0("-",thisOutline$LABELS[[1]][index])
    rightLabel <- paste0("+",thisOutline$LABELS[[1]][index])
  }

  label <- sprintf(base, leftLabel, rightLabel)

  return(label)
}

#' flattens data which includes checkbox responses
#' @param data: char vector
flattenData <- function(data){
  levels <- c()
  indices <- c()
  data$discrete <- toList(data$discrete)


  for(i in 1:NROW(data)){
    for(level in unlist(data[i,2])){
      levels <- c(levels, level)
      indices <- c(indices, i)
    }
  }

  continuous = data$continuous[indices]

  output <- data.frame(continuous, discrete = levels)


  if("fill" %in% names(data)){
    fill <- data$fill[indices]
    output$fill <- fill
  }

  return(output)

}

#' splits single strings of multiple levels seperated by ', ' into a list of vectors
#' of multiple strings
#' @param data: char vector
toList <- function(data){
  result <- sapply(data, function(x){
    x <- str_split(x, ", ") %>%
      unlist() %>%
      trimws("both")
  }, USE.NAMES = FALSE)

  return(result)
}

#' Generates a violin plot
#' @param continuous: a set of vector of continuous data
#' @param discrete: a set of discrete data of equal length to continuous
#' @param title: char, plot title
#' @param xlab: char, x axis label
#' @param ylab: char, y axis lable
#' @param flatten: logical, if true all responses within discrete data including
#' multiple selected levels will be treated as their own level,
#' if false responses with multiple selected levels will be split into multiple occurrences
#' @param showMean: logical indicating whether to add points to violins representing
#' mean value
violinPlot <- function(continuous, discrete = NULL, title = "Title",
                       xlab = "-xlab <---> +xlab", ylab = "ylab",
                       flatten = TRUE,
                       showMean = TRUE,
                       palette = NULL){

  if(is.null(discrete)){
    discrete <- rep("respones", NROW(continuous))
  }

  plotData <- data.frame(continuous, discrete)

  #%>%
    #na.omit()

  if(flatten){
    plotData <- flattenData(plotData)
  }

  plotData <- na.omit(plotData)

  #mapping = aes(fill = discrete)
  p <- ggplot(data = plotData, mapping = aes(x = continuous, y = discrete)) +
    geom_violin() +
    labs(title = title) +
    xlab(xlab) +
    ylab(ylab)

  if(showMean){
    p <- p + stat_summary(data = plotData, mapping = aes(x = continuous, y = discrete),
                          fun = "mean", geom = "point", shape = 8, size = 2,
                          color = "black")
  }

  #mycolors <- colorRampPalette(brewer.pal(8, "Set2"))(nb.cols)
  #scale_fill_manual(values = mycolors) +

  if(!(is.null(palette))){
    nLevels <- length(levels(as.factor(plotData$discrete)))

    thisPalette <- colorRampPalette(brewer.pal(8, palette))(nLevels)

    p <- p + aes(fill = discrete) +
      scale_fill_manual(values = thisPalette)
  }



  return(p)

}





